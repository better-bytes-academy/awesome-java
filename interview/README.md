# Câu hỏi phỏng vấn Java
Mục này chứa các câu hỏi phỏng vấn Java từ cơ bản tới nâng cao. Cách contribute vào repo:
1. Fork repo về GitHub cá nhân.
2. Thêm câu hỏi và câu trả lời tương ứng: Câu trả lời có 2 phần:
    - Trong file này: câu trả lời ngắn gọn
    - Tạo file tương ứng trong folder của level theo template

## Level beginner
| Câu hỏi | Tag | Câu trả lời |
|---------|-----|------------|
| [Java là gì và tại sao nó được gọi là "platform-independent"](beginner/001-what-is-java.md) | java_basic | Java là ngôn ngữ lập trình hướng đối tượng, và nó "platform-independent" nhờ JVM - Java Virtual Machine, cho phép mã bytecode chạy trên bất kỳ hệ điều hành nào có JVM |
| Sự khác biệt giữa JDK, JRE và JVM | java_basic | JDK là bộ công cụ phát triển, JRE là môi trường chạy Java, còn JVM là máy ảo thực thi bytecode |
| Khai báo biến trong Java như thế nào? Hãy cho một ví dụ | java_basic | Biến được khai báo với kiểu dữ liệu và tên, ví dụ: int number = 10; |
| Các kiểu dữ liệu cơ bản có sẵn trong Java? | java_basic | Java cung cấp 8 kiểu dữ liệu nguyên thủy (primitive data types), bao gồm: byte, short, int, long, float, double, char, và boolean. Những kiểu này giúp Java xử lý dữ liệu hiệu quả và tối ưu bộ nhớ. |
| Phương thức main trong Java là gì?  | java_basic | Phương thức main là điểm bắt đầu của mọi chương trình Java. Khi chạy chương trình, JVM sẽ tìm và thực thi phương thức main(). |
| Sự khác biệt giữa kiểu dữ liệu nguyên thủy và kiểu dữ liệu tham chiếu trong Java là gì? | java_basic | - **Kiểu dữ liệu nguyên thủy**: Lưu trữ giá trị trực tiếp trong bộ nhớ. <br> - **Kiểu dữ liệu tham chiếu**: Lưu trữ địa chỉ của đối tượng trong bộ nhớ Heap, không phải giá trị trực tiếp. |
| Sự khác biệt giữa Stack và Heap trong Java là gì? | java_basic | -	**Stack**: Bộ nhớ dành cho các biến cục bộ và lời gọi hàm, có tốc độ truy cập nhanh, quản lý theo cơ chế LIFO. <br> -	**Heap**: Bộ nhớ dành cho đối tượng và dữ liệu động, có thể truy cập toàn cục nhưng chậm hơn do cần quản lý bộ nhớ tự động (Garbage Collection). |
| Giải thích trình dọn rác (Garbage Collector) trong Java? | java_basic | Garbage Collector (GC) trong Java là một cơ chế tự động quản lý bộ nhớ, giúp loại bỏ các đối tượng không còn được tham chiếu để giải phóng bộ nhớ Heap. Điều này giúp lập trình viên không cần xóa thủ công như trong C/C++. |
| Khối static là gì? | java_basic | Khối static trong Java là một khối mã được thực thi chỉ một lần khi lớp được tải vào bộ nhớ, trước cả khi đối tượng của lớp được tạo ra hoặc phương thức main() chạy. |
| Các lớp Wrapper trong Java là gì? | java_basic | Các lớp Wrapper trong Java là các lớp trong gói java.lang dùng để bao bọc (wrap) kiểu dữ liệu nguyên thủy thành đối tượng. Điều này giúp làm việc với kiểu dữ liệu nguyên thủy dễ dàng hơn trong các cấu trúc yêu cầu đối tượng, như Collection (List, Set, Map). |
| Lệnh import được sử dụng ở đâu trong một chương trình Java? | java_basic | Lệnh import trong Java được sử dụng ở đầu tệp mã nguồn (trước khi khai báo lớp) để nhập các lớp hoặc gói cần thiết từ thư viện Java hoặc từ mã nguồn khác. Điều này giúp lập trình viên sử dụng các lớp mà không cần viết đầy đủ đường dẫn gói của chúng. |
| Tại sao Generic được sử dụng trong Java? | java_basic | Generic trong Java giúp tăng tính an toàn kiểu dữ liệu và tái sử dụng mã bằng cách cho phép xác định kiểu dữ liệu tại thời điểm biên dịch thay vì sử dụng kiểu Object. Điều này giúp tránh lỗi ép kiểu và làm cho mã nguồn dễ đọc hơn. |
| Tại sao Java không hỗ trợ con trỏ? | java_basic | Java không hỗ trợ con trỏ để đảm bảo an toàn bộ nhớ và giảm độ phức tạp lập trình. Việc sử dụng con trỏ có thể gây lỗi truy cập bộ nhớ hoặc rò rỉ bộ nhớ, nên Java thay thế bằng tham chiếu và Garbage Collector để quản lý bộ nhớ tự động.; |
| Câu lệnh break và continue là gì? | java_basic | - **break**: Dùng để thoát hoàn toàn khỏi vòng lặp hoặc switch-case ngay khi điều kiện được thỏa mãn. <br> - **continue**: Dùng để bỏ qua lần lặp hiện tại và chuyển sang lần lặp tiếp theo mà không thực hiện các lệnh phía sau nó. |
| Iterator là gì trong Java? | java_basic | Iterator trong Java là một interface trong java.util dùng để duyệt qua các phần tử của Collection (List, Set, Queue) một cách tuần tự mà không cần truy cập trực tiếp vào cấu trúc dữ liệu bên trong. Iterator hỗ trợ xóa phần tử an toàn trong khi duyệt qua danh sách. |
| Exception là gì trong Java? | java_basic | Exception trong Java là một sự kiện xảy ra trong quá trình thực thi chương trình, làm gián đoạn luồng chương trình bình thường. Java cung cấp cơ chế xử lý ngoại lệ để phát hiện và xử lý lỗi một cách an toàn, tránh làm chương trình bị dừng đột ngột. |
| Throw và Throws trong Java | java_basic | - **throw**: Dùng để ném một ngoại lệ cụ thể trong phương thức. <br> - **throws**: Khai báo một hoặc nhiều ngoại lệ mà phương thức có thể ném ra, yêu cầu xử lý ở nơi gọi nó. |
| Sự khác biệt giữa Checked Exception và Unchecked Exception? | java_basic | - **Checked Exception**: Ngoại lệ được kiểm tra tại thời điểm biên dịch, bắt buộc phải xử lý bằng try-catch hoặc throws. <br>- **Unchecked Exception**: Ngoại lệ xảy ra khi chương trình đang chạy, không bắt buộc phải xử lý, nhưng có thể gây lỗi chương trình. |
| finally trong Java dùng để làm gì? | java_basic | - finally là một khối mã đi kèm với try-catch, luôn được thực thi dù có ngoại lệ xảy ra hay không. - Thường dùng để giải phóng tài nguyên như đóng file, kết nối cơ sở dữ liệu,... |
| Sự khác biệt giữa == và .equals() khi so sánh chuỗi trong Java là gì? | java_basic | -	== so sánh địa chỉ ô nhớ của hai đối tượng. Nếu hai biến trỏ đến cùng một đối tượng trong bộ nhớ, nó trả về true, ngược lại trả về false.  <br>- .equals() so sánh nội dung chuỗi. Nếu hai chuỗi có cùng giá trị ký tự, nó trả về true, ngay cả khi chúng nằm ở các vùng nhớ khác nhau. |
| Sự khác nhau giữa Array và ArrayList trong Java? | java_basic | -	Array là cấu trúc dữ liệu tĩnh có kích thước cố định, trong khi ArrayList là danh sách động có thể thay đổi kích thước linh hoạt. <br> -	Array có hiệu suất tốt hơn khi truy cập phần tử, nhưng ArrayList cung cấp nhiều phương thức hỗ trợ giúp thao tác dữ liệu dễ dàng hơn. |
| Thế nào là lớp (Class) trong Java? | java_basic | Lớp (Class) trong Java là một khuôn mẫu để tạo ra các đối tượng (objects). Một lớp định nghĩa các thuộc tính (dữ liệu) và phương thức (hành vi) của đối tượng. |
| Đối tượng (Object) trong Java là gì? | java_basic | Đối tượng (Object) trong Java là một thể hiện cụ thể của một lớp (class). Đối tượng có trạng thái (thuộc tính) và hành vi (phương thức) được định nghĩa bởi lớp. |
| Tính đóng gói (Encapsulation) trong Java là gì? | java_basic | Tính đóng gói (Encapsulation) là một trong bốn tính chất của lập trình hướng đối tượng (OOP), giúp bảo vệ dữ liệu bằng cách che giấu thông tin bên trong lớp và chỉ cho phép truy cập thông qua các phương thức đặc biệt. |
| Tính kế thừa (Inheritance) trong Java là gì? | java_basic | Tính kế thừa (Inheritance) là một trong bốn tính chất của lập trình hướng đối tượng (OOP), cho phép một lớp con (child class) kế thừa các thuộc tính và phương thức từ một lớp cha (parent class). Điều này giúp tái sử dụng mã nguồn, giảm trùng lặp và tăng tính mở rộng của chương trình. |
| Tính đa hình (Polymorphism) trong Java là gì? | java_basic | Tính đa hình (Polymorphism) là một trong bốn tính chất của lập trình hướng đối tượng (OOP), cho phép một phương thức có thể có nhiều cách thực hiện khác nhau, tùy thuộc vào ngữ cảnh. Trong Java, tính đa hình có hai dạng chính: đa hình tại thời điểm biên dịch (compile-time polymorphism) và đa hình tại thời điểm chạy (runtime polymorphism). |
| Tính trừu tượng (Abstraction) trong Java là gì? | java_basic | Tính trừu tượng (Abstraction) là một trong bốn tính chất quan trọng của lập trình hướng đối tượng (OOP). Nó cho phép ẩn đi chi tiết triển khai và chỉ hiển thị những thông tin cần thiết cho người dùng. Trong Java, tính trừu tượng được thực hiện thông qua lớp trừu tượng (abstract class) và giao diện (interface). |
| Từ khóa final trong Java là gì? | java_basic | final là một từ khóa trong Java được sử dụng để định nghĩa hằng số, ngăn chặn kế thừa hoặc ngăn chặn ghi đè phương thức. <br> - final với biến: Giá trị không thể thay đổi sau khi gán. <br> - final với phương thức: Không thể bị ghi đè (override) trong lớp con. <br> - final với lớp: Không thể bị kế thừa. |
| Constructor là gì? Có bao nhiêu loại constructor trong Java? | java_basic | Constructor là một phương thức đặc biệt trong Java được gọi tự động khi tạo đối tượng, dùng để khởi tạo giá trị cho các biến của lớp. |
| Từ khóa instanceof trong Java là gì? | java_basic | Từ khóa instanceof trong Java được dùng để kiểm tra xem một đối tượng có phải là thể hiện của một lớp hoặc một lớp con của nó hay không. |
| Sự khác biệt giữa vòng lặp while và vòng lặp do-while trong Java là gì? | java_basic | Vòng lặp while và do-while đều dùng để thực thi một đoạn mã lặp đi lặp lại dựa trên điều kiện. <br>-	while kiểm tra điều kiện trước khi thực hiện vòng lặp → Nếu điều kiện sai ngay từ đầu, vòng lặp không chạy lần nào. <br>-	do-while thực thi ít nhất một lần rồi mới kiểm tra điều kiện → Đảm bảo vòng lặp luôn chạy ít nhất một lần. |
| Từ khóa super và this trong Java là gì? | java_basic | super và this là hai từ khóa quan trọng trong Java, dùng để tham chiếu đến các thành phần khác nhau của lớp.<br>-	super: Dùng để gọi constructor hoặc phương thức của lớp cha (superclass).<br>-	this: Dùng để tham chiếu đến biến, phương thức hoặc constructor của chính lớp hiện tại. |
| Upcasting và Downcasting trong Java là gì? | java_basic | Upcasting và Downcasting là hai loại ép kiểu trong Java khi làm việc với kế thừa.<br>-	Upcasting: Ép kiểu từ lớp con lên lớp cha (an toàn, tự động hoặc tường minh).<br>-	Downcasting: Ép kiểu từ lớp cha xuống lớp con (cần tường minh, có thể gây lỗi ClassCastException). |
| Tại sao Java không hỗ trợ đa kế thừa? | java_basic | Java không hỗ trợ đa kế thừa giữa các lớp để tránh vấn đề "Diamond Problem" và đơn giản hóa thiết kế. Thay vào đó, Java sử dụng kế thừa đơn (single inheritance) kết hợp với interface để đạt được tính linh hoạt. |
| Có thể thay đổi quyền truy cập (access modifier) của phương thức khi override không? | java_basic | Có thể thay đổi access modifier khi override, nhưng phải tuân theo nguyên tắc:<br>- Có thể mở rộng quyền truy cập (từ chặt hơn → rộng hơn).<br>- Không thể thu hẹp quyền truy cập (từ rộng hơn → chặt hơn). |
| Khai báo biến trong Java như thế nào? Hãy cho một ví dụ | java_basic | Biến được khai báo với kiểu dữ liệu và tên, ví dụ: int number = 10; |
| Khai báo biến trong Java như thế nào? Hãy cho một ví dụ | java_basic | Biến được khai báo với kiểu dữ liệu và tên, ví dụ: int number = 10; |
| Khai báo biến trong Java như thế nào? Hãy cho một ví dụ | java_basic | Biến được khai báo với kiểu dữ liệu và tên, ví dụ: int number = 10; |
| Khai báo biến trong Java như thế nào? Hãy cho một ví dụ | java_basic | Biến được khai báo với kiểu dữ liệu và tên, ví dụ: int number = 10; |
| Khai báo biến trong Java như thế nào? Hãy cho một ví dụ | java_basic | Biến được khai báo với kiểu dữ liệu và tên, ví dụ: int number = 10; |
## Level intermediate
| Câu hỏi | Tag | Câu trả lời |
|---------|-----|------------|
| Explain the internal working of ConcurrentHashMap. How does it achieve thread safety, and what are its performance trade-offs | java_collection | [Xem chi tiết](intermediate/000-concurrent-hashmap.md) |
| Câu hỏi 2 | Tag 2 | Câu trả lời 2 |
| Câu hỏi 3 | Tag 3 | Câu trả lời 3 |
## Level advance
